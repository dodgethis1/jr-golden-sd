<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>JR Golden SD</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; }
    .box { border: 1px solid #ccc; border-radius: 12px; padding: 12px; margin: 12px 0; }
    .warn { border-color: #b00; }
    .mode { font-size: 22px; font-weight: 800; }
    .pill { display:inline-block; padding: 2px 10px; border-radius: 999px; background:#f3f3f3; }
    code, pre { background: #f3f3f3; padding: 8px; border-radius: 10px; overflow:auto; }
    input, select, button { font-size: 16px; padding: 8px; }
    button { cursor: pointer; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row > * { flex: 1 1 220px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .log { max-height: 340px; overflow:auto; white-space: pre-wrap; word-break: break-word; }
    .small { font-size: 12px; opacity: 0.85; }
  </style>
</head>
<body>
  <h2>JR Golden SD</h2>

  <div class="box" id="headline">Loading…</div>

  <div class="grid">
    <div class="box" id="urls">Loading URLs…</div>
    <div class="box" id="qr">Loading QR…</div>
  </div>

  <div class="box warn" id="policy">Loading policy…</div>

  <div class="box" id="targetsBox">Loading disks…</div>

  <div class="box" id="planner">
    <b>Flash Plan (dry-run):</b><br><br>

    <div class="row">
      <label>Target disk (eligible only):<br>
        <select id="target"></select>
      </label>

      <label>OS search:<br>
        <input id="q" placeholder="raspberry pi os, twister, ubuntu…" style="width:100%">
      </label>

      <label>OS choice (top 250 results):<br>
        <select id="os"></select>
      </label>
    </div>

    <br>
    <button id="planBtn">Generate plan (dry-run)</button>
    <button id="dlBtn">Download OS to cache</button>
    <div id="planOut" style="margin-top:12px;"></div>
    <div id="dlOut" style="margin-top:12px;"></div>

    <hr style="margin:16px 0;">

    <b>ARM (still no writes):</b><br>
    <small>You must type the safety word and the exact target. This arms for a short time only.</small><br><br>

    <div class="row">
      <label>Write word (ALL CAPS):<br>
        <input id="word" placeholder="ERASE">
      </label>

      <label>Confirm target (exact):<br>
        <input id="confirmTarget" placeholder="/dev/nvme0n1">
      </label>

      <label>Serial suffix (optional, last 4):<br>
        <input id="serialSuffix" placeholder="0111">
      </label>
    </div>

    <br>
    <button id="armBtn">ARM (no write)</button>
    <button id="disarmBtn">DISARM</button>

    <div id="armOut" style="margin-top:12px;"></div>
  </div>

  <div class="box" id="jobbox">
    <b>Job monitor:</b> <span class="pill" id="jobState">idle</span><br>
    <small class="small">Watches <code>/api/job/&lt;id&gt;</code> and tails logs via <code>/api/job/&lt;id&gt;/tail</code> (read-only).</small><br><br>

    <div class="row">
      <label>Job ID:<br>
        <input id="jobId" placeholder="paste job_id here" style="width:100%">
      </label>

      <div>
        <br>
        <button id="followJobBtn">Follow job</button>
        <button id="stopJobBtn">Stop</button>
      </div>
    </div>

    <div id="jobStatus" style="margin-top:12px;"></div>
    <div style="margin-top:12px;"><b>Live log (last 200 lines):</b></div>
    <pre id="jobLog" class="log mono"></pre>
  </div>

<script>
async function j(url, opts={}){
  const retries = Number.isFinite(opts.retries) ? opts.retries : 12;
  const baseDelayMs = Number.isFinite(opts.delay_ms) ? opts.delay_ms : 250;

  let lastErr = null;
  for (let i=0; i<retries; i++){
    try{
      const r = await fetch(url, { cache: "no-store" });
      const txt = await r.text();

      if (!r.ok){
        const msg = (txt || "").trim().slice(0, 300);
        throw new Error(`HTTP ${r.status} ${r.statusText}${msg ? (": " + msg) : ""}`);
      }
      if (!txt || !txt.trim()){
        throw new Error("empty response");
      }
      return JSON.parse(txt);
    } catch (e){
      lastErr = e;
      const wait = Math.min(1200, baseDelayMs * (i + 1));
      await new Promise(res => setTimeout(res, wait));
    }
  }
  throw lastErr || new Error("request failed");
}

function opt(el, value, text){
  const o = document.createElement("option");
  o.value = value; o.textContent = text;
  el.appendChild(o);
}

async function loadOS(q=""){
  const osSel = document.getElementById("os");
  osSel.innerHTML = "";
  const data = await j("/api/os" + (q ? ("?q=" + encodeURIComponent(q)) : ""));
  (data.items || []).forEach(it => {
    opt(osSel, it.id, `${it.name}  [${it.provider_label}]`);
  });
}

function tsToLocal(ts){
  if (!ts) return "";
  try { return new Date(ts * 1000).toLocaleString(); } catch { return ""; }
}

// JR_STATUS_PANEL_V1: Mode banner + allowed targets panel + startup-retry
function esc(x){
  return String(x ?? "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}
function fmtDisk(d){
  const path = d.path || "";
  const size = d.size ? ` (${esc(d.size)})` : "";
  const tran = d.tran ? ` ${esc(d.tran)}` : "";
  const model = d.model ? ` • ${esc(d.model)}` : "";
  const serial = d.serial ? ` • ${esc(String(d.serial).slice(-8))}` : "";
  return `<span class="mono">${esc(path)}</span>${size}<span class="small"> • ${tran}${model}${serial}</span>`;
}
function renderStatus(safety, disks, armStatus){
  const headline = document.getElementById("headline");
  const policy = document.getElementById("policy");
  const targetsBox = document.getElementById("targetsBox");
  if (!headline || !policy || !targetsBox) return;

  const st = (safety && safety.state) || {};
  const pol = (safety && safety.policy) || {};
  const ver = (safety && safety.version) ? safety.version : "";

  const mode = st.mode || "unknown";
  const rootParent = st.root_parent || "";
  const rootSource = st.root_source || "";
  const rootDisk = rootParent ? ("/dev/" + rootParent) : "(unknown)";

  const armed = (armStatus && armStatus.active) || (safety && safety.armed && safety.armed.active) || false;
  const armedExpires = (safety && safety.armed && safety.armed.expires_at) ? tsToLocal(safety.armed.expires_at) : "";

  const flashEnabled = !!pol.flash_enabled;
  const flashTxt = flashEnabled ? "ENABLED" : "DISABLED";
  const canFlashHere = (pol.can_flash_here !== undefined) ? String(!!pol.can_flash_here) : "unknown";

  headline.innerHTML =
    `<div class="row" style="align-items:flex-start;">` +
      `<div style="flex: 2 1 360px;">` +
        `<div class="mode">Mode: <span class="pill">${esc(mode)}</span></div>` +
        `<div class="small">Root disk: <span class="mono">${esc(rootDisk)}</span> (root_source: <span class="mono">${esc(rootSource)}</span>)</div>` +
        `<div class="small">Version: <span class="mono">${esc(ver)}</span></div>` +
      `</div>` +
      `<div style="flex: 1 1 260px;">` +
        `<div><b>Armed:</b> <span class="pill">${armed ? "YES" : "no"}</span></div>` +
        `<div class="small">${(armed && armedExpires) ? ("Expires: " + esc(armedExpires)) : ""}</div>` +
      `</div>` +
    `</div>`;

  policy.classList.toggle("warn", !flashEnabled);
  policy.innerHTML =
    `<b>Policy:</b><br>` +
    `<div class="small">Flash policy: <span class="pill">${flashTxt}</span></div>` +
    `<div class="small">Can flash here (mode rules): <span class="pill">${esc(canFlashHere)}</span></div>` +
    `<div class="small">Write word: <span class="pill">${esc(pol.write_word || "")}</span> • Arm TTL: <span class="pill">${esc(pol.arm_ttl_seconds ?? "")}s</span></div>` +
    `<div class="small">Root disk blocked: <span class="pill">${esc(pol.root_disk_blocked ?? "")}</span> • Requires SD mode: <span class="pill">${esc(pol.requires_sd_mode ?? "")}</span></div>`;

  const disksList = (disks && disks.disks) ? disks.disks : [];
  const eligible = (safety && safety.eligible_targets) ? safety.eligible_targets : [];
  const eligiblePaths = new Set(eligible.map(x => x.path));

  const allowedLines = eligible.length
    ? ("<ul>" + eligible.map(d => `<li>${fmtDisk(d)}</li>`).join("") + "</ul>")
    : "<div class='small'>(none)</div>";

  const blocked = disksList.filter(d => !eligiblePaths.has(d.path));
  const blockedLines = blocked.length
    ? ("<ul>" + blocked.map(d => {
          const reason = d.is_root_disk ? "blocked: root disk" : "blocked: not eligible in current mode";
          return `<li>${fmtDisk(d)} <span class="pill">${esc(reason)}</span></li>`;
        }).join("") + "</ul>")
    : "<div class='small'>(none)</div>";

  targetsBox.innerHTML =
    `<b>Allowed targets (eligible now):</b>${allowedLines}` +
    `<hr style="margin:12px 0;">` +
    `<b>Detected disks (blocked):</b>${blockedLines}`;
}

let _statusTimer = null;

async function refreshStatusOnce(){
  try {
    await j("/api/health", {retries: 12, delay_ms: 250});
    const safety = await j("/api/safety", {retries: 12, delay_ms: 250});
    const disks  = await j("/api/disks",  {retries: 12, delay_ms: 250});
    const arm    = await j("/api/arm_status", {retries: 12, delay_ms: 250});
    renderStatus(safety, disks, arm);
    syncPlannerFromSafety(safety);
  } catch (e) {
    const headline = document.getElementById("headline");
    const targetsBox = document.getElementById("targetsBox");
    if (headline) headline.textContent = "Backend starting… (retrying)";
    if (targetsBox) targetsBox.textContent = "Waiting for backend…";
  }
}

function startStatusPoll(){
  if (_statusTimer) return;
  refreshStatusOnce();
  _statusTimer = setInterval(refreshStatusOnce, 5000);
}
window.addEventListener("load", startStatusPoll);
// end JR_STATUS_PANEL_V1

// JR_PLANNER_UX_V1: planner quality-of-life + guardrails (still NO new capabilities)
let _plannerTargetsSig = null;

function targetsSig(list){
  try { return (list || []).map(x => x.path).join("|"); } catch { return ""; }
}

function syncPlannerFromSafety(safety){
  const tSel = document.getElementById("target");
  const confirmEl = document.getElementById("confirmTarget");
  const wordEl = document.getElementById("word");

  const eligible = (safety && safety.eligible_targets) ? safety.eligible_targets : [];
  const pol = (safety && safety.policy) ? safety.policy : {};

  if (tSel){
    const sig = targetsSig(eligible);
    const prev = tSel.value || "";
    if (sig !== _plannerTargetsSig){
      tSel.innerHTML = "";
      eligible.forEach(d => {
        const label = `${d.path} (${d.size||""} ${d.model||""} ${d.serial||""})`;
        opt(tSel, d.path, label);
      });
      if (prev && eligible.some(d => d.path === prev)) tSel.value = prev;
      _plannerTargetsSig = sig;
    }
  }

  const curTarget = (tSel && tSel.value) ? tSel.value : "";
  if (confirmEl){
    confirmEl.placeholder = curTarget || confirmEl.placeholder || "";
    if (!confirmEl.value) confirmEl.value = curTarget || "";
  }

  if (wordEl){
    const ww = (pol && pol.write_word) ? String(pol.write_word) : "";
    wordEl.placeholder = ww || wordEl.placeholder || "";
    if (!wordEl.value && ww) wordEl.value = ww;
  }
}

async function ensureTargetsLoaded(){
  const tSel = document.getElementById("target");
  if (tSel && tSel.options && tSel.options.length > 0) return;
  const safety = await j("/api/safety", {retries: 12, delay_ms: 250});
  syncPlannerFromSafety(safety);
}
// end JR_PLANNER_UX_V1

let lastPlan = null;

// --- Job monitor (status + live log tail) ---
let pollTimer = null;

function setJobState(txt){
  const el = document.getElementById("jobState");
  if (el) el.textContent = txt;
}

function isNearBottom(el, slack=24){
  try { return (el.scrollTop + el.clientHeight + slack) >= el.scrollHeight; } catch { return true; }
}

function stopJobPoll(){
  if (pollTimer){ clearInterval(pollTimer); pollTimer = null; }
  setJobState("idle");
}

function guessState(job){
  if (!job || typeof job !== "object") return "unknown";
  const s = job.state || job.status || job.phase || job.result;
  if (typeof s === "string") return s;
  if (job.ok === false) return "error";
  if (job.exit_code !== undefined && job.exit_code !== null) return (job.exit_code === 0 ? "success" : "failed");
  if (job.done === true) return "done";
  if (job.pid) return "running";
  return "unknown";
}

function formatJobSummary(job){
  if (!job || typeof job !== "object") return "";
  const parts = [];
  if (job.id) parts.push("id=" + job.id);
  if (job.type) parts.push("type=" + job.type);
  if (job.pid) parts.push("pid=" + job.pid);
  if (job.exit_code !== undefined && job.exit_code !== null) parts.push("exit_code=" + job.exit_code);
  if (job.created_at) parts.push("created=" + tsToLocal(job.created_at));
  if (job.updated_at) parts.push("updated=" + tsToLocal(job.updated_at));
  if (job.started_at) parts.push("started=" + tsToLocal(job.started_at));
  if (job.ended_at) parts.push("ended=" + tsToLocal(job.ended_at));
  return parts.join(" • ");
}

async function pollJobOnce(jobId){
  const statusEl = document.getElementById("jobStatus");
  const logEl = document.getElementById("jobLog");
  if (!statusEl || !logEl) return;

  // status
  let job = null;
  try {
    const r = await fetch("/api/job/" + encodeURIComponent(jobId));
    if (!r.ok) {
      const t = await r.text();
      setJobState("HTTP " + r.status);
      statusEl.innerHTML = `<b>Status:</b> <span class="pill">HTTP ${r.status}</span><pre>${esc(t)}</pre>`;
      return;
    }
    job = await r.json();
  } catch (e) {
    setJobState("error");
    statusEl.innerHTML = `<b>Status:</b> <span class="pill">error</span><pre>${esc(String(e))}</pre>`;
    return;
  }

  const state = guessState(job);
  setJobState(state);

  statusEl.innerHTML =
    `<b>Status:</b> <span class="pill">${esc(state)}</span><br>` +
    `<small class="small">${esc(formatJobSummary(job))}</small>` +
    `<pre>${esc(JSON.stringify(job, null, 2))}</pre>`;

  // log tail
  try {
    const r2 = await fetch("/api/job/" + encodeURIComponent(jobId) + "/tail?lines=200");
    if (r2.ok) {
      const tail = await r2.json();
      const wasNear = isNearBottom(logEl);
      logEl.textContent = (tail.lines || []).join("\n");
      if (wasNear) logEl.scrollTop = logEl.scrollHeight;
    }
  } catch {
    // ignore log errors
  }

  // stop polling when done-ish
  if (state === "success" || state === "failed" || state === "done") {
    if (pollTimer){ clearInterval(pollTimer); pollTimer = null; }
  }
}

function startJobFollow(jobId){
  jobId = (jobId || "").trim();
  if (!jobId) return;
  stopJobPoll();
  const jobIdEl = document.getElementById("jobId");
  if (jobIdEl) jobIdEl.value = jobId;
  setJobState("starting");
  pollJobOnce(jobId);
  pollTimer = setInterval(() => pollJobOnce(jobId), 1500);
}

// Main init
(async () => {
  const u = await j("/api/urls", {retries: 12, delay_ms: 250});
  document.getElementById("urls").innerHTML =
    `<b>Open this from your phone/PC:</b>
     <ul>${(u.urls||[]).map(x => `<li><a href="${x}">${x}</a></li>`).join("")}</ul>`;
  const first = (u.urls && u.urls[0]) ? u.urls[0] : location.origin + "/";
  document.getElementById("qr").innerHTML =
    `<b>QR (scan me):</b><br><img src="/api/qr?u=${encodeURIComponent(first)}" alt="QR"><br><small><code>${esc(first)}</code></small>`;

  // Prime status + planner once early
  try { await refreshStatusOnce(); } catch {}
  await ensureTargetsLoaded();

  const tSel = document.getElementById("target");
  const confirmEl = document.getElementById("confirmTarget");

  if (tSel && confirmEl){
    confirmEl.placeholder = tSel.value || confirmEl.placeholder || "";
    if (!confirmEl.value) confirmEl.value = tSel.value || "";
    tSel.addEventListener("change", () => {
      confirmEl.value = tSel.value;
      confirmEl.placeholder = tSel.value;
    });
  }

  await loadOS("");

  document.getElementById("q").addEventListener("change", async (e) => {
    await loadOS(e.target.value || "");
  });

  document.getElementById("planBtn").addEventListener("click", async () => {
    const out = document.getElementById("planOut");
    if (out) out.innerHTML = `<span class="pill">working…</span>`;

    await ensureTargetsLoaded();

    const target = (tSel && tSel.value) ? tSel.value : "";
    const os_id = (document.getElementById("os").value || "").trim();

    if (!target || !os_id){
      if (out) out.innerHTML = `<b>Plan error:</b> <span class="pill">missing</span> select a target and OS.`;
      return;
    }

    let data = null;
    try{
      const r = await fetch("/api/plan_flash", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ target, os_id })
      });
      const txt = await r.text();
      data = txt ? JSON.parse(txt) : {};
      if (!r.ok || (data && data.ok === false)){
        const msg = (data && data.error) ? data.error : (txt || `HTTP ${r.status}`);
        throw new Error(msg);
      }
    } catch(e){
      if (out) out.innerHTML = `<b>Plan error:</b><pre>${esc(String(e))}</pre>`;
      return;
    }

    lastPlan = {
      target,
      os_id,
      plan_id: data.plan_id || null,
      expires_at: data.expires_at || null,
      data
    };

    const exp = data.expires_at ? tsToLocal(data.expires_at) : "";
    const pid = data.plan_id ? `<code>${esc(data.plan_id)}</code>` : `<span class="pill">missing plan_id</span>`;

    if (out) out.innerHTML =
      `<b>Plan:</b><br>` +
      `<div class="small">Target: <span class="mono">${esc(target)}</span> • OS: <span class="mono">${esc(os_id)}</span></div>` +
      `<div class="small">plan_id: ${pid}${exp ? (" • Expires: <span class='mono'>" + esc(exp) + "</span>") : ""}</div>` +
      `<div class="small">Next: ARM will send this plan_id automatically (still no writes).</div>` +
      `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`;

    try { await refreshStatusOnce(); } catch {}
  });

  document.getElementById("armBtn").addEventListener("click", async () => {
    await ensureTargetsLoaded();

    const target = (tSel && tSel.value) ? tSel.value : "";
    const os_id = (document.getElementById("os").value || "").trim();
    const word = document.getElementById("word").value || "";
    const confirm_target = document.getElementById("confirmTarget").value || "";
    const serial_suffix = document.getElementById("serialSuffix").value || "";

    const r = await fetch("/api/arm", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ target, os_id, word, confirm_target, serial_suffix })
    });
    const txt = await r.text();
    const data = txt ? JSON.parse(txt) : {};

    document.getElementById("armOut").innerHTML =
      `<b>ARM response:</b><pre>${esc(JSON.stringify(data, null, 2))}</pre>`;

    try { await refreshStatusOnce(); } catch {}
  });

  document.getElementById("dlBtn").addEventListener("click", async () => {
    const os_id = (document.getElementById("os").value || "").trim();
    const r = await fetch("/api/download_os", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ os_id })
    });
    const txt = await r.text();
    const data = txt ? JSON.parse(txt) : {};

    document.getElementById("dlOut").innerHTML =
      `<b>Download request:</b><pre>${esc(JSON.stringify(data, null, 2))}</pre>`;
  });

  document.getElementById("disarmBtn").addEventListener("click", async () => {
    const r = await fetch("/api/disarm", { method: "POST" });
    const txt = await r.text();
    const data = txt ? JSON.parse(txt) : {};

    document.getElementById("armOut").innerHTML =
      `<b>DISARM response:</b><pre>${esc(JSON.stringify(data, null, 2))}</pre>`;

    try { await refreshStatusOnce(); } catch {}
  });
})();

// Job monitor buttons
try {
  document.getElementById("followJobBtn").addEventListener("click", async () => {
    const id = (document.getElementById("jobId").value || "").trim();
    startJobFollow(id);
  });
  document.getElementById("stopJobBtn").addEventListener("click", async () => {
    stopJobPoll();
  });
} catch (e) {
  console.warn("job monitor wiring failed:", e);
}
</script>
</body>
</html>
